<?php

/**
 * A reporting interface to the MediaWiki API interfacing with the CiviCRM API
 *
 * @copyright 2015 Gregory Scott Rundlett <greg@freephile.com>
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  You should have received a copy of the GNU Affero General Public License
 *  along with this program in the LICENSE file
 *  If not, see <http://www.gnu.org/licenses/>.
 */

namespace eqt\wikireport;

/**
 * UrlWiki is for working with URLs that are MediaWiki related
 * 
 * Specifically, it can tell if a URL is generated by MediaWiki.
 * 
 * In so doing, it will also set the $apiUrl and $wikiUrl
 * 
 * @todo rewrite the file_get_contents code to use fsockopen() and stream_get_meta_data()
 * so that we can control how long we wait for bogus URLs
 * 
 * usage example:
 * $UrlWiki = new \eqt\wikireport\UrlWiki($url);
 *
 * @author greg
 */
class UrlWiki extends \eqt\wikireport\Url {
    public $orginalUrl;
    
    public $url;
    
    public $wikiUrl; // base
    
    public $sitename; // from json data
    
    public $generator; // version string
    
    public $apiUrl;
    
    public $msg;
    
    public $parsedUrl;
    
    private $isWiki;
    
    public $data;
    
    public $versionString;
    
    public $error; // an integer that corresponds to the Civi Group (11 = Perms/No API)

    function __construct($url) {
        parent::__construct($url);
        $timer = new \eqt\wikireport\Profiler();
        $timer->stopwatch();
        $this->find_endpoint();
        $timer->stopwatch();
        $this->msg[] = $timer->getElapsedTime( __METHOD__ . " took ", "on line ". __LINE__, false);
    }

    /** 
     * A function to take a URL, and find the api endpoint using available heuristics.
     * We return true unless we can NOT connect.  Thus, a weak guess is still 'true'
     * The side-effect of this method is that $this->apiUrl is set.
     * Once $this->apiUrl is set, we can actually determine if it's a wiki and
     * more importantly, we can pass it over to MwApi() to handle API calls.
     * 
     * @param optional string $url is the full URI of the MediaWiki api.php
     * If any URI produced by a MediaWiki installation is given, we will do our best
     * to determine what the URI of api.php is.
     */
    function find_endpoint($url = null) {
        if ( is_null($url) ) {
            $url = $this->url;
        }
        $this->msg[] = "finding an endpoint for $url";
        if ( substr($url, -7) == 'api.php' ) {
            $this->msg[] = "given a URL ending with api.php, so using that for \$this->apiUrl";
            $this->apiUrl = $url;
            return true;
        } else {
            // we only redirect if starting off without an endpoint (api.php)
            $this->find_redirect();
            $data = $this->curl_get($this->url);
            switch ($data) {
                // short-circuit if we can't even connect to $this->url    
                case ($data === false) :
                    $this->msg[] = __METHOD__ . ": Unable to connect to $this->url (bad URL?)";
                    return false;
                // As of v1.17 The API now has a Really Simple Discovery module, 
                // useful for publishing service information by the API. 
                // The RSD link looks like
                // <link rel="EditURI" type="application/rsd+xml" href="https://freephile.org/w/api.php?action=rsd" />
                // <link rel="EditURI" type="application/rsd+xml" href="//en.wikipedia.org/w/api.php?action=rsd" />
                // if ( preg_match( '#<link rel="EditURI" type="application/rsd\+xml" href="(.*)\?action=rsd"#', $data, $matches) ) {
                case ( preg_match('#EditURI.* href\="(.*)\?action\=rsd"#U', $data, $matches) && $matches[1] ):
                    $this->apiUrl = $matches[1];
                    $this->prefix_scheme($this->parsedUrl['scheme'], $this->apiUrl);
                    $this->msg[] = __METHOD__ . " setting apiUrl ($this->apiUrl) from EditURI/Really Simple Discovery";
                    break;
                
                // Find api.php from the RSS feed link (accurate)
                case ( preg_match('#link rel="alternate" type="application/(?:rss|atom)[^>]* href="(.*)\?title=#U', $data, $matches) && $matches[1] ):
                    $this->apiUrl = str_ireplace('index.php', 'api.php', $matches[1]);
                    $this->make_absolute($this->apiUrl);
                    $this->msg[] = __METHOD__ . " setting apiUrl ($this->apiUrl) from RSS link";
                    break;

                // older versions of MediaWiki don't have a EditURI link, but 
                // do have the "generator" link so, if we detect that, then we'll
                // <meta name="generator" content="MediaWiki 1.15.1" />
                // <meta name="generator" content="MediaWiki 1.16.5" />
                case ( preg_match('#meta name="generator"[^>]* content="(MediaWiki[^"]+)"#U', $data, $matches) && $matches[1] ):
                    $this->guess_api();
                    $this->msg[] = __METHOD__ . " found generator, guessing api ($this->apiUrl)";
                    break;

                default:
                    $this->guess_api();
                    $this->msg[] = __METHOD__ . ": We guessed at $this->apiUrl (given $this->url)";
            }
            return true;
        }

    }
    /**
     * getter/setter for $this->isWiki
     * 
     * Using a tell-tale 'signature' of a MediaWiki generated page, we can tell
     * if a particular URI is generated by MediaWiki.
     * 
     * @return (bool) $this->isWiki
     */
    function isWiki () {
        $apiQuery = '?action=query&meta=siteinfo&format=json&siprop=general';
        
        if( isset($this->isWiki) ) {
            $this->msg[] = "isWiki was already set.  Returning $this->isWiki.";
            return $this->isWiki;
        }
        if ( $this->find_endpoint() ) {
            $this->isWiki = true;
        }
        $url = $this->apiUrl . $apiQuery;
        $json = $this->curl_get($url);
        if ( strstr($json, 'wgEnableAPI') ) {
            // we don't have json, we have an error message that the API is not enabled
            $this->msg[] = __METHOD__ . " although a wiki, we're returning false because the API is not enabled. (try Special:Version)";
            $this->error = 11;
            $this->isWiki = false;
            return false;
        }
        // echo "<pre>"; var_dump($json); echo "</pre>";
        $this->data = json_decode($json, true);
        // echo "<pre>"; var_dump($this->data); echo "</pre>";
        if ( isset($this->data['error']) && !empty($this->data['error']) ) {
            // echo "<pre>"; var_dump($this->data); echo "</pre>";
            $this->msg[] = __METHOD__ . " although a wiki, we're returning false because of code {$this->data['error']['code']} meaning {$this->data['error']['info']}";
            $this->error = 11;
            $this->isWiki = false;
            return false;
        }
        $this->wikiUrl = $this->data['query']['general']['base'];
        $this->sitename = $this->data['query']['general']['sitename'];
        $this->generator = $this->data['query']['general']['generator'];
        $this->versionString =  trim(str_ireplace("MediaWiki", '', $this->generator));

        $this->msg[] = __METHOD__ . ": wiki found at $this->wikiUrl via $this->apiUrl (starting with $this->orginalUrl)";

        return $this->isWiki;
    }
    
    function guess_api() {
        $apiUrl = $this->parsedUrl['scheme'] . '://';
        $apiUrl .= $this->parsedUrl['host'];
        $apiUrl .= isset($this->parsedUrl['port'])? ':' . $this->parsedUrl['port'] : '';
        // if the path contains 'index.php', grab the portion before that; eg. wiki/index.php.
        if (strstr($this->parsedUrl['path'], 'index.php')) { 
            $apiUrl .= substr($this->parsedUrl['path'], 0, 
                    strpos($this->parsedUrl['path'], 'index.php'));
        } elseif (strstr($this->parsedUrl['path'], 'wiki')) { 
        // clean URLs with 'wiki' (no index.php), grab the portion before that (probably just a slash)
            $apiUrl .= substr($this->parsedUrl['path'], 0, 
                    strpos($this->parsedUrl['path'], 'wiki'));
            $apiUrl .= 'w'; // add back the 'wiki' portion
        }
        $apiUrl .= "/api.php";
        $this->apiUrl = $apiUrl;
        return $apiUrl;
    }   

}