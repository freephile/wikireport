<?php

/**
 * A reporting interface to the MediaWiki API interfacing with the CiviCRM API
 *
 * @copyright 2015 Gregory Scott Rundlett <greg@freephile.com>
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  You should have received a copy of the GNU Affero General Public License
 *  along with this program in the LICENSE file
 *  If not, see <http://www.gnu.org/licenses/>.
 */

namespace eqt\wikireport;

/**
 * UrlWiki is for working with URLs that are MediaWiki related
 * 
 * Specifically, it can tell if a URL is generated by MediaWiki.
 * 
 * In so doing, it will also set the $apiUrl and $wikiUrl
 * 
 * @todo rewrite the file_get_contents code to use fsockopen() and stream_get_meta_data()
 * so that we can control how long we wait for bogus URLs
 * 
 * usage example:
 * $UrlWiki = new \eqt\wikireport\UrlWiki($url);
 *
 * @author greg
 */
class UrlWiki extends \eqt\wikireport\Url {
    const GIVEN = "API URL given";
    const NO_CONNECTION = "Error: unable to connect";
    const REALLY_SIMPLE_DISCOVERY = "RSD (Really Simple Discovery)";
    const RSS_ATOM = "RSS ATOM feed";
    const GENERATOR  = "Generator tag found";
    const GUESS  = "we guessed";
    const GUESS1 = "variant 1 replaced index.php with api.php";
    const GUESS2 = "variant 2 strip wiki/";
    const GUESS3 = "variant 3 keep anything 'wiki-ish' but throw away trailing path";
    const GUESS4 = "variant 4 replace wiki-ish with w";
    const GUESS5 = "variant 5 replace wiki-ish with mediawiki";
    const CONNECT_TIMEOUT = 5; // also in the parent class
    
    // for the types of conditions we find in is_wiki()
    // not really fleshed out yet
    public $isWikiErrors = array(
     0 => "API is not enabled. (try Special:Version)",
     11 => '', // we don't have json, we have an error message that the API is not enabled
    );


    public $orginalUrl;
    
    public $url;
    
    public $wikiUrl; // base
    
    public $sitename; // from json data
    
    public $generator; // version string
    
    public $apiUrl;
    
    public $msg;
    
    public $parsedUrl;
    
    private $isWiki;
    
    public $data;
    
    public $endpointMethod;
    
    public $versionString;
    
    public $error; // an integer that corresponds to the Civi Group (11 = Perms/No API)

    function __construct($url) {
        parent::__construct($url);
        $timer = new \eqt\wikireport\Profiler();
        $timer->stopwatch();
        $this->endpoint_set($url);
        $timer->stopwatch();
        $this->msg[] = $timer->getElapsedTime( __METHOD__ . " set_endpoint() took ", " seconds on line ". __LINE__, false);
    }

    /** 
     * A function to take a URL, and find the api endpoint using available heuristics.
     * We return true unless we can NOT connect.  Thus, a weak guess is still 'true'
     * The side-effect of this method is that $this->apiUrl is set.
     * Once $this->apiUrl is set, we can actually determine if it's a wiki and
     * more importantly, we can pass it over to MwApi() to handle API calls.
     * 
     * @param optional string $url is the full URI of the MediaWiki api.php
     * If any URI produced by a MediaWiki installation is given, we will do our best
     * to determine what the URI of api.php is.
     */
    function endpoint_set($url = null) {
        if ( is_null($url) ) {
            $url = $this->url;
        }
        if ( substr($url, -7) == 'api.php' ) {
            $this->endpointMethod = self::GIVEN; // 0 GIVEN
            $apiUrl = $url;
        } else {
            //follow any "Location: " header that the server sends 
            $opts = array(
                CURLOPT_FOLLOWLOCATION => 1, 
            );
            $data = $this->curl_get($url, null, $opts);
            self::removeBOM($data);
            switch ($data) {
                // short-circuit if we can't even connect to $this->url    
                case ($data === false) :
                    $apiUrl = null;  // nuclear
                    $this->endpointMethod = self::NO_CONNECTION; // 5 NO_CONNECTION
                // As of v1.17 The API now has a Really Simple Discovery module, 
                // useful for publishing service information by the API. 
                // The RSD link looks like
                // <link rel="EditURI" type="application/rsd+xml" href="https://freephile.org/w/api.php?action=rsd" />
                // <link rel="EditURI" type="application/rsd+xml" href="//en.wikipedia.org/w/api.php?action=rsd" />
                // if ( preg_match( '#<link rel="EditURI" type="application/rsd\+xml" href="(.*)\?action=rsd"#', $data, $matches) ) {
                case ( preg_match('#EditURI.* href\="(.*)\?action\=rsd"#U', $data, $matches) && $matches[1] ):
                    $apiUrl = $matches[1];
                    // var_dump($matches);
                    $this->endpointMethod = self::REALLY_SIMPLE_DISCOVERY; // 1 REALLY_SIMPLE_DISCOVERY
                    $apiUrl = $this->prefix_scheme($this->parsedUrl['scheme'], $apiUrl);
                    break;
                
                // Find api.php from the RSS feed link (accurate)
                case ( preg_match('#link rel="alternate" type="application/(?:rss|atom)[^>]* href="(.*)\?title=#U', $data, $matches) && $matches[1] ):
                    $apiUrl = str_ireplace('index.php', 'api.php', $matches[1]);
                    $this->endpointMethod = self::RSS_ATOM; // 2 RSS_ATOM
                    $this->make_absolute($apiUrl); // we sometimes get relative links
                    break;

                // older versions of MediaWiki don't have a EditURI link, but 
                // do have the "generator" link so, if we detect that, then we'll
                // <meta name="generator" content="MediaWiki 1.15.1" />
                // <meta name="generator" content="MediaWiki 1.16.5" />
                case ( preg_match('#meta name="generator"[^>]* content="(MediaWiki[^"]+)"#U', $data, $matches) && $matches[1] ):
                    $apiUrl = $this->endpoint_guess();
                    $this->endpointMethod = self::GENERATOR; // 3 GENERATOR
                    break;

                default:
                    $apiUrl = $this->endpoint_guess();
                    $this->endpointMethod = self::GUESS; // 4 GUESS
            }
        }
        $this->apiUrl = $apiUrl;
        // logging
        $this->msg[] = __METHOD__ . " set apiUrl ($apiUrl) from " . $this->endpointMethod;
    }
    
    /**
     * Remove the Byte Order Mark (BOM) from files
     * @param mixed $data is the contents of a file, which may have a binary BOM
     * @return bool true if the BOM was removed
     */
    static function removeBOM(&$data) {
        if (0 === strpos(bin2hex($data), 'efbbbf')) {
           $data = substr($data, 3);
           return true;
        }
        return false;
    }
    /**
     * getter/setter for $this->isWiki
     * 
     * function depends on having $this->apiUrl set
     * 
     * Depending on the outcome of testing apiUrl, we will know that a URL is
     * or is not a wiki.
     * 
     * Furthermore, we will know that for a "good" wiki, whether there is a
     * problem or restriction such as the API not being set, or there being read
     * permission restrictions on the API.  Thus a side-effect of this method should
     * be that group memberships for a contact (url) are set in CiviCRM
     * 
     * 
     * The url we are testing (CiviCRM contact)
     * is a member of one of the following groups (established in Civi CRM)
     * We can use the CiviApi::createGroup() method to assign to group membership
     * $groups = array (
     * 3 = > "MediaWiki,
     * 11 => "Read Restricted",
     * 12 => "Not Wiki",
     * 13 => "No API", // API is not enabled. (try Special:Version)
     * 14 => "No email",
     * );
     *
     * The constructor will set
     * 
        [orginalUrl] => https://freephile.org/wiki/Main_Page
        [url]  => https://freephile.org/wiki/Main_Page
 =====> [apiUrl] => https://freephile.org/w/api.php    <========================
        [endpointMethod] => RSD (Really Simple Discovery)
        [parsedUrl] => Array (
            [scheme] => https
            [host] => freephile.org
            [path] => /wiki/Main_Page )
     * 
     * As a result of running this method, we ALSO have the following
     *  
 =====> [isWiki:eqt\wikireport\UrlWiki:private] => 1   <========================
        [wikiUrl] => https://freephile.org/wiki/Main_Page
        [sitename] => Wiki
        [generator] => MediaWiki 1.25beta
        [versionString] => 1.25beta
        [data] => (array of siprop=general) data['query']['general']
     * @var array $opts optional settings for curl
     * @return (bool) $this->isWiki
     */
    function is_wiki (array $opts=array()) {
        $apiQuery = '?action=query&meta=siteinfo&format=json&siprop=general';
        // I don't think this is necessary because there is no other setter
        if( isset($this->isWiki) ) {
            $this->error = 0;
            $this->msg[] = "isWiki was already set.  Returning $this->isWiki.";
            return $this->isWiki;
        }
        if (empty($this->apiUrl)) {
            return false;
            die (__METHOD__ . " was called without apiUrl being set");
        }
        $url = $this->apiUrl . $apiQuery;
        $opts += array(
            CURLOPT_FOLLOWLOCATION => 1, //follow any "Location: " header that the server sends 
            CURLOPT_HEADER => 0, // include the header in the output.
            CURLOPT_FAILONERROR => 0, // don't fail on error
            CURLOPT_SSL_VERIFYPEER => false, // stop cURL from verifying the peer's certificate
            CURLOPT_CONNECTTIMEOUT => self::CONNECT_TIMEOUT, // @todo make this a configuration constant/variable
        );

        $json = $this->curl_get($url, null, $opts);
        // var_dump($json);
        if ( strstr($json, 'wgEnableAPI') ) {
            // we don't have json, we have an error message that the API is not enabled
            $this->msg[] = "API is not enabled. (try Special:Version)";
            $this->error = 13;
            $this->isWiki = true;
            return true;
        }
        // note that PHP warnings emitted in the HTML (broken website) will 
        // break our decode, and thus be considered "not a wiki"
        // some servers insert a BOM which breaks JSON!!!!
        $hadBOM = self::removeBOM($json);
        // may need to stripslashes also
        /*
        if (strstr($json, '\\/')) { // if we see http:\/\/foo.example.com
            $json = stripslashes($json);
        }
         * 
         */

        $this->data = json_decode($json, true);
        if(json_last_error() === JSON_ERROR_NONE) {
            // echo "we have good json";
            // The MediaWiki api will tell us if we don't have access or there is some internal problem with the API
            if ( isset($this->data['error']) && !empty($this->data['error']) ) {
                $this->msg[] = __METHOD__ . " MediaWiki gave us {$this->data['error']['code']} meaning {$this->data['error']['info']}";
                $this->error = 11;
                $this->isWiki = true;
            } else {
                // we've decoded the json, and we have no errors
                $this->wikiUrl = $this->data['query']['general']['base'];
                $this->sitename = $this->data['query']['general']['sitename'];
                $this->generator = $this->data['query']['general']['generator'];
                $this->versionString =  trim(str_ireplace("MediaWiki", '', $this->generator));

                $this->msg[] = __METHOD__ . ": wiki found at $this->wikiUrl via $this->apiUrl (starting with $this->orginalUrl)";
                $this->isWiki = true;
            }
        } else {
            $this->msg[] = __METHOD__ . " unable to decode JSON " . json_last_error() . " : " .  json_last_error_msg();
            $this->error = 12; // Not Wiki
            $this->isWiki = false;
        }
        
        return $this->isWiki;
    }
    
    /**
     * A simple test would look like this:
     * (the method is invoked in the constructor)
     * 
        $url = "http://colorwiki.com/wiki/ColorWiki_Home";
        $UrlWiki = new \eqt\wikireport\UrlWiki($url);
        print $UrlWiki->apiUrl;
     *  
     * returns 
     * 
       "http://colorwiki.com/api.php";
     * 
     * 
     * @return mixed the URL of the MediaWiki api on success or false on failure
     */
    function endpoint_guess() {
        $apiUrl = $this->parsedUrl['scheme'] . '://' . $this->parsedUrl['host'];
        $apiUrl .= isset($this->parsedUrl['port'])? ':' . $this->parsedUrl['port'] : '';

        // if the path contains 'index.php', grab the portion before that; eg. wiki/index.php.
        $path = $this->parsedUrl['path'];
        $pathVariants = array();
        
        // variant 1 replace index.php with api.php
        if (strstr($path, 'index.php')) { 
            $variant = substr($path, 0, strpos($path, 'index.php'));// up to but not including index.php
            $pathVariants[] = $variant;
            $this->endpointMethod = self::GUESS1;
        }
        if (strstr($path, 'wiki/')) { 
            $variant = substr($path, 0, strpos($path, 'wiki/'));
            $pathVariants[] = $variant;
            $this->endpointMethod = self::GUESS2;
        }
        if ($variant = preg_replace("#/([^/]*wiki[^/]*)/(.*)#i", "/$1/", $path)) {
            $pathVariants[] = $variant;
            $this->endpointMethod = self::GUESS3;
        }
        if ($variant = preg_replace("#/([^/]*wiki[^/]*)/(.*)#i", "/w/", $path)) {
            $pathVariants[] = $variant;
            $this->endpointMethod = self::GUESS4;
        }        
        if ($variant = preg_replace("#/([^/]*wiki[^/]*)/(.*)#i", "/mediawiki/", $path)) {
            $pathVariants[] = $variant;
            $this->endpointMethod = self::GUESS5;
        }

        foreach ($pathVariants as $variant) {
            $test = $apiUrl . $variant . "api.php";
            $headers = get_headers($test, 1);
            if (stristr($headers[0], '200') && in_array("MediaWiki-API-Error", array_keys($headers)) ) {
                return $apiUrl = $test;
            }
        }
        return false;
    }   

}